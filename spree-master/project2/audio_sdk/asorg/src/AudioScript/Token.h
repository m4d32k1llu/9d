/***********************************************************\
Copyright (C) James Boer, 2002. 
All rights reserved worldwide.

This software is provided "as is" without express or implied
warranties. You may freely copy and compile this source into
applications you distribute provided that the copyright text
below is included in the resulting source code, for example:
"Portions Copyright (C) James Boer, 2002"
\***********************************************************/
#pragma once

#ifndef __TOKEN_H
#define __TOKEN_H

#pragma warning(disable:4786)
#pragma warning(disable:4251)

#define TOKEN_DEBUGGING_INFO

namespace Audio
{

struct TokenVector3D
{
	float x;
	float y;
	float z;
};

// This is the basic data object generated by the Parser class
class Token 
{
public:
	enum TOKEN_TYPE
	{
		UNKNOWN_TOKEN = 0,
		KEYWORD,
		OPERATOR,
		VARIABLE,
		STRING,
		INTEGER,
		REAL,
		BOOLEAN,
		VECTOR,
		T_GUID
	};


	Token()						{  Clear();  }
	Token(const Token& tok);
	virtual ~Token()			{  Term();  }
	void Clear();

	void operator = ( const Token& tok);

	inline bool InitKeyword(const char* pszKeyword)
	{
		m_Type = KEYWORD;
		m_pszKeyword = new char[strlen(pszKeyword) + 1];
		if(!m_pszKeyword)
			return false;
		strcpy(m_pszKeyword, pszKeyword);
		return true;
	}

	inline bool InitOperator(const char* pszOperator)
	{
		m_Type = OPERATOR;
		m_pszOperator = new char[strlen(pszOperator) + 1];
		if(!m_pszOperator)
			return false;
		strcpy(m_pszOperator, pszOperator);
		return true;
	}

	inline bool InitVariable(const char* pszVariable)
	{
		m_Type = VARIABLE;
		m_pszVariable = new char[strlen(pszVariable) + 1];
		if(!m_pszVariable)
			return false;
		strcpy(m_pszVariable, pszVariable);
		return true;
	}

	inline bool InitString(const char* pszString)
	{
		m_Type = STRING;
		m_pszString = new char[strlen(pszString) + 1];
		if(!m_pszString)
			return false;
		strcpy(m_pszString, pszString);
		return true;
	}

	inline bool InitInteger(int iInteger)
	{
		m_Type = INTEGER;
		m_iInteger = iInteger;
		return true;
	}

	inline bool InitReal(double dReal)
	{
		m_Type = REAL;
		m_dReal = dReal;
		return true;
	}

	inline bool InitBoolean(bool bBoolean)
	{
		m_Type = BOOLEAN;
		m_bBoolean = bBoolean;
		return true;
	}

	inline bool InitVector(const TokenVector3D& vec3D)
	{
		m_Type = VECTOR;
		m_pvVector = new TokenVector3D;
		if(!m_pvVector)
			return false;
		memcpy(m_pvVector, &vec3D, sizeof(TokenVector3D));
		return true;
	}

	inline bool InitGuid(const GUID& guidGuid)
	{
		m_Type = T_GUID;
		m_pguidGuid = new GUID;
		if(!m_pguidGuid)
			return false;
		memcpy(m_pguidGuid, &guidGuid, sizeof(GUID));
		return true;
	}

	void Term();

	inline void SetVariable(const char* pszVariable)
	{
		assert(m_Type == VARIABLE);
		delete[] m_pszVariable;
		m_pszVariable = 0;
		InitVariable(pszVariable);
	}

	inline void SetKeyword(const char* pszKeyword)
	{
		assert(m_Type == KEYWORD);
		delete[] m_pszKeyword;
		m_pszKeyword = 0;
		InitKeyword(pszKeyword);
	}

	inline void SetString(const char* pszString)
	{
		assert(m_Type == STRING);
		delete[] m_pszString;
		m_pszString = 0;
		InitString(pszString);
	}

	inline void SetOperator(const char* pszOperator)
	{
		assert(m_Type == OPERATOR);
		delete[] m_pszOperator;
		m_pszOperator = 0;
		InitOperator(pszOperator);
	}

	inline void SetInteger(const int iInteger)
	{
		assert(m_Type == INTEGER);
		InitInteger(iInteger);
	}

	inline void SetBoolean(const bool bBoolean)
	{
		assert(m_Type == BOOLEAN);
		InitBoolean(bBoolean);
	}

	inline void SetReal(const double dReal)
	{
		assert(m_Type == REAL);
		InitReal(dReal);
	}

	inline void SetVector(const TokenVector3D& vVector)
	{
		assert(m_Type == VECTOR);
		delete m_pvVector;
		m_pvVector = 0;
		InitVector(vVector);
	}

	inline void SetGuid(const GUID& guidGuid)
	{
		assert(m_Type == T_GUID);
		delete m_pguidGuid;
		m_pguidGuid = 0;
		InitGuid(guidGuid);
	}

	// querry the type of token
	inline bool IsUnknown()	const		{  return (m_Type == UNKNOWN_TOKEN) ? true : false;  }
	inline bool IsKeyword()	const		{  return (m_Type == KEYWORD) ? true : false;  }
	inline bool IsOperator() const		{  return (m_Type == OPERATOR) ? true : false;  }
	inline bool IsVariable() const		{  return (m_Type == VARIABLE) ? true : false;  }
	inline bool IsString() const		{  return (m_Type == STRING) ? true : false;  }
	inline bool IsInteger()	const		{  return (m_Type == INTEGER) ? true : false;  }
	inline bool IsReal() const			{  return (m_Type == REAL) ? true : false;  }
	inline bool IsBoolean()	const		{  return (m_Type == BOOLEAN) ? true : false;  }
	inline bool IsVector() const		{  return (m_Type == VECTOR) ? true : false;  }
	inline bool IsGuid() const			{  return (m_Type == T_GUID) ? true : false;  }
	inline TOKEN_TYPE GetType() const	{  return m_Type;  }

	// get the token content
	inline const char* GetKeyword() const	{  assert(m_Type == KEYWORD);  return (const char*)m_pszKeyword;  }
	inline const char* GetOperator() const	{  assert(m_Type == OPERATOR);  return (const char*)m_pszOperator;  }
	inline const char* GetVariable() const	{  assert(m_Type == VARIABLE);  return (const char*)m_pszVariable;  }
	inline const char* GetString() const	{  assert(m_Type == STRING);  return (const char*)m_pszString;  }
	inline int GetInteger() const			{  assert(m_Type == INTEGER);  return m_iInteger;  }
	inline double GetReal() const			{  assert(m_Type == REAL);  return m_dReal;  }
	inline bool GetBoolean() const			{  assert(m_Type == BOOLEAN);  return m_bBoolean;  }
	inline TokenVector3D& GetVector() const	{  assert(m_Type == VECTOR);  return *m_pvVector;  }
	inline GUID& GetGuid() const			{  assert(m_Type == T_GUID);  return *m_pguidGuid;  }

	inline bool IsNewline() const			{  return (IsOperator() && (GetOperator()[0] == '\n')) ? true : false;  }

	const char* GetDescriptiveString() const;
	
#ifdef TOKEN_DEBUGGING_INFO
	inline void SetLineNumber(int iLineNo)	{  m_iLineNumber = iLineNo;  }
	inline int GetLineNumber() const		{  return m_iLineNumber;  }
	inline void SetFileIndex(int iIndex)	{  m_iFileIndex = iIndex;  }
	inline int GetFileIndex() const			{  return m_iFileIndex;  }
#endif // TOKEN_DEBUGGING_INFO


protected:

	// This tells us which type of data we're carrying
	TOKEN_TYPE m_Type;

	// The data is in one of these fields.  We're only going to be using
	// one type per token, so no reason to waste space.  So, we make
	// the data fields part of a union.
	union
	{
		char*			m_pszKeyword;
		char*			m_pszOperator;
		char*			m_pszVariable;
		char*			m_pszString;
		int				m_iInteger;
		double			m_dReal;
		bool			m_bBoolean;
		TokenVector3D*	m_pvVector;
		GUID*			m_pguidGuid;
	};

#ifdef TOKEN_DEBUGGING_INFO
	// Indicates the line number in which the token was found.
	// Note that although this is debugging information, it should
	// not only be contained in debug builds, since we may want to
	// "debug" release mode applications which still will be using
	// this parser.
	int m_iLineNumber;

	// References an index into a string table containing the source
	// file in which this token was found.
	int m_iFileIndex;
#endif // TOKEN_DEBUGGING_INFO

};

// stream operators
// this is to support a tokenized file representation of a parsed file
inline std::ostream& operator<<( std::ostream& os, Token& tok );
inline std::istream& operator>>( std::istream& is, Token& tok );


typedef std::vector<std::string> StringVector;
typedef std::vector<Token> TokenVector;

typedef std::list<Token>::iterator TokenListItor;

// TokenList is the standard list type for tokens.  It's a basic STL list
// of type token with some enhancements for storing and retrieving debugging info
class TokenList : public std::list<Token>
{
public:

	// Gets a descriptive string of the token including file name and line number
	std::string GetDescriptiveString(TokenListItor itr) const;
	// Gets a string of the file name from where the token was parsed
	//std::string GetFileName(TokenListItor itr) const;
	std::string GetFileName(int index) const;
	// Gets the line number of the token
	int GetLineNumber(TokenListItor itr) const;
	
	// Given a filename, find the index into the filelist vector.  If it doesn't
	// currently exist in the vector, push it onto the end and return the
	// new index value.
	int GetFileIndex(std::string sFileName);

	// Get the total number of file references in this token list
	int GetNumFileRefs() const;

	void clear();
	
private:
	StringVector m_aFileRef;
};

}; // namespace Audio

#endif // __TOKEN_H